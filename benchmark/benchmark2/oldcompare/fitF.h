/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
  * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

#ifndef FITF
#define FITF

#include "RooAbsPdf.h"
#include "RooRealProxy.h"
#include "RooCategoryProxy.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"

#define knri 9
#define kmaxpar 5
#define kmaxndecay 10
#define kmaxpaths 100
//#define neueff 0.613384

#define kmaxparms 100

Int_t pnpaths=100;
Int_t pknri=200;
Int_t pndecay[kmaxpaths];
Int_t pdecaymap[kmaxpaths][kmaxndecay];
Int_t pnneu[kmaxpaths][kmaxndecay];

TString riname[kmaxparms];
Double_t parms[kmaxparms];
Double_t parmserr[kmaxparms];
Double_t parmsmax[kmaxparms];
Double_t parmsmin[kmaxparms];
Int_t isparmsfix[kmaxparms];
Double_t mcparms[kmaxparms];
Int_t nparmsactive = 0;
Int_t indexparmsactive[kmaxparms];


Int_t nisomers = 0;
Int_t groundstate[kmaxparms];
Int_t isomerstate[kmaxparms];
Bool_t flag_sum_isomer_ratio=false;

//!---------- MAKE PATH------------------------------------------//
//!--------------------------------------------------------------//
typedef struct {
    // idendification
    Int_t id;
    Int_t z;
    Int_t n;
    TString name;

    // decay properies
    Double_t decay_hl;
    Double_t decay_lamda;

    Double_t population_ratio;//isomer population ratio
    Double_t population_ratioerr;
    Double_t population_ratioup;
    Double_t population_ratiolow;

    Double_t decay_p0n;//decay to several isomerics states or ground state
    Double_t decay_p1n;
    Double_t decay_p2n;

    Double_t decay_hlerr;
    Double_t decay_lamdaerr;
    Double_t decay_p0nerr;
    Double_t decay_p1nerr;
    Double_t decay_p2nerr;

    Double_t decay_hlup;
    Double_t decay_lamdaup;
    Double_t decay_p0nup;
    Double_t decay_p1nup;
    Double_t decay_p2nup;

    Double_t decay_hllow;
    Double_t decay_lamdalow;
    Double_t decay_p0nlow;
    Double_t decay_p1nlow;
    Double_t decay_p2nlow;

    // fit options 0-vary, 1-fix with error propagation, 2-fix without error propagation
    Int_t is_decay_hl_fix;
    Int_t is_decay_lamda_fix;
    Int_t is_decay_p0n_fix;
    Int_t is_decay_p1n_fix;
    Int_t is_decay_p2n_fix;

    Int_t is_population_ratio_fix;

    // paths to this ri
    vector< vector<Int_t> > path;
    vector< vector<Int_t> > nneupath;
    vector< vector<Double_t> > branching;
} MemberDef;

void ProcessMember(MemberDef* obj)
{
    //! further processing
    if (obj->decay_hl<0){
        obj->decay_hl=-obj->decay_hl;
        obj->is_decay_hl_fix=0;
    }else{//exclude decay half-life =0;
        obj->is_decay_hl_fix=1;
    }


    // convert half-life into activity
    obj->decay_lamda=log(2)/obj->decay_hl;
    obj->decay_lamdaerr=log(2)/obj->decay_hl/obj->decay_hl*obj->decay_hlerr;
    obj->decay_lamdalow=log(2)/obj->decay_hlup;
    obj->decay_lamdaup=log(2)/obj->decay_hllow;
    obj->is_decay_lamda_fix=obj->is_decay_hl_fix;

    if (obj->decay_p1n<0){
        obj->decay_p1n=-obj->decay_p1n;
        obj->is_decay_p1n_fix=0;
    }else if (obj->decay_p1n==0){//exclude decay with pn = 0;
        obj->is_decay_p1n_fix=2;
    }else{
        obj->is_decay_p1n_fix=1;
    }

    if (obj->decay_p2n<0){
        obj->decay_p2n=-obj->decay_p2n;
        obj->is_decay_p2n_fix=0;
    }else if (obj->decay_p2n==0){//exclude decay half-life =0;
        obj->is_decay_p2n_fix=2;
    }else{
        obj->is_decay_p2n_fix=1;
    }

    // convert pn in % to pn in 1
    obj->decay_p1n=obj->decay_p1n/100;
    obj->decay_p1nerr=obj->decay_p1nerr/100;
    obj->decay_p1nlow=obj->decay_p1nlow/100;
    obj->decay_p1nup=obj->decay_p1nup/100;

    obj->decay_p2n=obj->decay_p2n/100;
    obj->decay_p2nerr=obj->decay_p2nerr/100;
    obj->decay_p2nlow=obj->decay_p2nlow/100;
    obj->decay_p2nup=obj->decay_p2nup/100;
}

void CopyMember(MemberDef* source, MemberDef* destination)
{
    destination-> id = source->  id;
    destination-> z = source->  z;
    destination-> n = source->  n;
    destination-> name = source->  name;

    destination-> decay_hl = source->  decay_hl;
    destination-> decay_lamda = source->  decay_lamda;

    destination-> population_ratio = source->  population_ratio;
    destination-> population_ratioerr = source->  population_ratioerr;
    destination-> population_ratioup = source->  population_ratioup;
    destination-> population_ratiolow = source->  population_ratiolow;

    destination-> decay_p0n = source->  decay_p0n;
    destination-> decay_p1n = source->  decay_p1n;
    destination-> decay_p2n = source->  decay_p2n;

    destination-> decay_hlerr = source->  decay_hlerr;
    destination-> decay_lamdaerr = source->  decay_lamdaerr;
    destination-> decay_p0nerr = source->  decay_p0nerr;
    destination-> decay_p1nerr = source->  decay_p1nerr;
    destination-> decay_p2nerr = source->  decay_p2nerr;

    destination-> decay_hlup = source->  decay_hlup;
    destination-> decay_lamdaup = source->  decay_lamdaup;
    destination-> decay_p0nup = source->  decay_p0nup;
    destination-> decay_p1nup = source->  decay_p1nup;
    destination-> decay_p2nup = source->  decay_p2nup;

    destination-> decay_hllow = source->  decay_hllow;
    destination-> decay_lamdalow = source->  decay_lamdalow;
    destination-> decay_p0nlow = source->  decay_p0nlow;
    destination-> decay_p1nlow = source->  decay_p1nlow;
    destination-> decay_p2nlow = source->  decay_p2nlow;


    destination-> is_decay_hl_fix = source->  is_decay_hl_fix;
    destination-> is_decay_lamda_fix = source->  is_decay_lamda_fix;
    destination-> is_decay_p0n_fix = source->  is_decay_p0n_fix;
    destination-> is_decay_p1n_fix = source->  is_decay_p1n_fix;
    destination-> is_decay_p2n_fix = source->  is_decay_p2n_fix;
}


void readinput(char* infilename, list<MemberDef*>& list)
{
    Int_t id=0;
    nisomers = 0;
    std::string line;
    std::ifstream infile(infilename);
    while (std::getline(infile, line))
    {
        std::istringstream iss(line);
        if (line[0]=='#') continue;
        Int_t a;
        // decay properies
        MemberDef* obj=new MemberDef();
        obj->id=id;

        //! read info without isomer
//        if (!(iss >> obj->name >> obj->z >> a >> obj->decay_hl >> obj->decay_hlerr >> obj->decay_hllow >> obj->decay_hlup >>
//              obj->decay_p1n >> obj->decay_p1nerr >> obj->decay_p1nlow >> obj->decay_p1nup >>
//              obj->decay_p2n >> obj->decay_p2nerr >> obj->decay_p2nlow >> obj->decay_p2nup)) break;

        obj->population_ratio = 1;
        obj->population_ratioerr = 0;
        obj->population_ratiolow = 0;
        obj->population_ratioup = 2;
        obj->is_population_ratio_fix = 2;

        //! read info with isomer
        if (!(iss >> obj->name >> obj->z >> a >> obj->decay_hl >> obj->decay_hlerr >> obj->decay_hllow >> obj->decay_hlup >>
              obj->decay_p1n >> obj->decay_p1nerr >> obj->decay_p1nlow >> obj->decay_p1nup >>
              obj->decay_p2n >> obj->decay_p2nerr >> obj->decay_p2nlow >> obj->decay_p2nup)) break;
        obj->n=a-obj->z;

        Bool_t flagisomer = false;
        std::string tempstring(obj->name.Data());
        MemberDef* objisomer;
        if (tempstring.back()=='*') {
            objisomer=new MemberDef();
            CopyMember(obj,objisomer);
            objisomer->id = obj->id + 1;
            cout<<"ISOMER of "<<obj->name<<endl;
            if (!(iss >> objisomer->population_ratio >> objisomer->population_ratioerr >> objisomer->population_ratiolow >> objisomer->population_ratioup >> objisomer->decay_hl >> objisomer->decay_hlerr >> objisomer->decay_hllow >> objisomer->decay_hlup >>
                  objisomer->decay_p1n >> objisomer->decay_p1nerr >> objisomer->decay_p1nlow >> objisomer->decay_p1nup >>
                  objisomer->decay_p2n >> objisomer->decay_p2nerr >> objisomer->decay_p2nlow >> objisomer->decay_p2nup)) break;
            obj->name = TString(tempstring.substr(0,tempstring.length()-1).data());

            if (objisomer->population_ratio>0){
                obj->is_population_ratio_fix = 1;
                objisomer->is_population_ratio_fix = 1;
            }else{
                objisomer->population_ratio = -objisomer->population_ratio;
                obj->is_population_ratio_fix = 0;
                objisomer->is_population_ratio_fix = 0;
            }

            obj->population_ratio = 1 - objisomer->population_ratio;
            obj->population_ratioerr = objisomer->population_ratioerr;
            obj->population_ratioup = 1 - objisomer->population_ratiolow;
            obj->population_ratiolow = 1 - objisomer->population_ratioup;



            flagisomer = true;
        }

        //! ground state
        ProcessMember(obj);
        list.emplace(list.end(),obj);
        id++;

        if (flagisomer){
            //! isomeric state
            ProcessMember(objisomer);
            list.emplace(list.end(),objisomer);
            id++;

            groundstate[nisomers] = obj->id;
            isomerstate[nisomers] = objisomer->id;
            nisomers++;
        }

    }

}

void appendvectors(vector< vector<Int_t> >& pathoriginal,vector< vector<Int_t> >& pathnew,Int_t newmember,vector< vector<Int_t> >& nneupathoriginal,vector< vector<Int_t> >& nneupathnew,Int_t nneunewmember)
{

    //! Vectors containing information about the node in the decay network
    // if original vector is empty (parent nuclei)
    if (pathoriginal.size()==0){
        vector<Int_t> row;
        row.push_back(0);
        row.push_back(newmember);
        pathnew.push_back(row);
    }

    // if original vector is not empty
    for (Size_t i=0;i<pathoriginal.size();i++)
    {
        // copy original vector
        vector<Int_t> row;
        for (Size_t j=0;j<pathoriginal[i].size();j++)
        {
            row.push_back(pathoriginal[i][j]);
        }
        // add one more element to the row
        row.push_back(newmember);
        pathnew.push_back(row);
    }

    //! Vectors containing information about how many neutron emitted in a decay
    // if original vector is empty (parent nuclei)
    if (nneupathoriginal.size()==0){
        vector<Int_t> nneurow;
        nneurow.push_back(-1); // no meaning for first row
        nneurow.push_back(nneunewmember);
        nneupathnew.push_back(nneurow);
    }

    // if original vector is not empty
    for (Size_t i=0;i<nneupathoriginal.size();i++)
    {
        // copy original vector
        vector<Int_t> nneurow;
        for (Size_t j=0;j<nneupathoriginal[i].size();j++)
        {
            nneurow.push_back(nneupathoriginal[i][j]);
        }
        // add one more element to the row
        nneurow.push_back(nneunewmember);
        nneupathnew.push_back(nneurow);
    }
}

int makepath(char* inputfile)
{
    list<MemberDef*> listofdecaymember;
    list<MemberDef*>::iterator listofdecaymember_it;
    list<MemberDef*>::iterator listofdecaymember_it2;
    readinput(inputfile,listofdecaymember);

    // display information of the decay members
    for (listofdecaymember_it = listofdecaymember.begin(); listofdecaymember_it != listofdecaymember.end(); listofdecaymember_it++)
    {
        cout<<(*listofdecaymember_it)->id+1<<"\t"<<(*listofdecaymember_it)->name<<"\t"<<(*listofdecaymember_it)->z<<"\t"<<
              (*listofdecaymember_it)->n<<"\t"<<(*listofdecaymember_it)->n+(*listofdecaymember_it)->z<<"\t"<<(*listofdecaymember_it)->decay_hl<<"\t"<<(*listofdecaymember_it)->decay_lamda<<"\t"<<
              (*listofdecaymember_it)->decay_p1n<<"\t"<<(*listofdecaymember_it)->decay_p2n<<"\t"<<
              (*listofdecaymember_it)->is_decay_hl_fix<<"\t"<<(*listofdecaymember_it)->is_decay_p1n_fix<<"\t"<<(*listofdecaymember_it)->is_decay_p2n_fix<<endl;
    }

    // main loop
    for (listofdecaymember_it = listofdecaymember.begin(); listofdecaymember_it != listofdecaymember.end(); listofdecaymember_it++)
    {
        for (listofdecaymember_it2 = listofdecaymember.begin(); listofdecaymember_it2 != listofdecaymember.end(); listofdecaymember_it2++)
        {
            if (((*listofdecaymember_it)->z-(*listofdecaymember_it2)->z)==1){
                if (((*listofdecaymember_it)->n-(*listofdecaymember_it2)->n)==-1){//p0n
                    appendvectors((*listofdecaymember_it2)->path,(*listofdecaymember_it)->path,(*listofdecaymember_it)->id,
                                  (*listofdecaymember_it2)->nneupath,(*listofdecaymember_it)->nneupath,0);
                }else if (((*listofdecaymember_it)->n-(*listofdecaymember_it2)->n)==-2){//p1n
                    appendvectors((*listofdecaymember_it2)->path,(*listofdecaymember_it)->path,(*listofdecaymember_it)->id,
                                  (*listofdecaymember_it2)->nneupath,(*listofdecaymember_it)->nneupath,1);
                }else if (((*listofdecaymember_it)->n-(*listofdecaymember_it2)->n)==-3){//p2n
                    appendvectors((*listofdecaymember_it2)->path,(*listofdecaymember_it)->path,(*listofdecaymember_it)->id,
                                  (*listofdecaymember_it2)->nneupath,(*listofdecaymember_it)->nneupath,2);
                }
            }
        }
    }

    // pass the listofdecaymember to the old arrays used for global function
    pnpaths=0;

    Double_t minz=100000;
    Double_t minn=100000;
    Double_t maxz=0;
    Double_t maxn=0;

    Double_t expandZ=3;
    Double_t expandN=3;

    for (listofdecaymember_it = listofdecaymember.begin(); listofdecaymember_it != listofdecaymember.end(); listofdecaymember_it++)
    {
        if ((*listofdecaymember_it)->z<minz) minz=(*listofdecaymember_it)->z;
        if ((*listofdecaymember_it)->n<minn) minn=(*listofdecaymember_it)->n;

        if ((*listofdecaymember_it)->z>maxz) maxz=(*listofdecaymember_it)->z;
        if ((*listofdecaymember_it)->n>maxn) maxn=(*listofdecaymember_it)->n;

        for (Size_t i=0;i<(*listofdecaymember_it)->path.size();i++){
            pndecay[pnpaths]=(*listofdecaymember_it)->path[i].size();
            for (Size_t j=0;j<(*listofdecaymember_it)->path[i].size();j++){
                pdecaymap[pnpaths][(Int_t)j]=(*listofdecaymember_it)->path[i][j];
            }

            for (Size_t j=1;j<(*listofdecaymember_it)->path[i].size();j++){
                pnneu[pnpaths][(Int_t)j-1]=(*listofdecaymember_it)->nneupath[i][j];
            }

            pnpaths++;
        }
    }

    cout<<"EEEEEE"<<endl;
    for (Int_t i=0;i<pnpaths;i++){
        for (Int_t j=0;j<pndecay[i];j++){
            cout<<pdecaymap[i][j]<<"\t";
            //pnneu[i][j]=pnneu[i][j];
        }
        cout<<endl;
    }
    cout<<"EEEEEE"<<endl;



    // number of ri
    pknri=listofdecaymember.size();

    Int_t k=0;
    // put in parms variable
    for (listofdecaymember_it = listofdecaymember.begin(); listofdecaymember_it != listofdecaymember.end(); listofdecaymember_it++)
    {
        char tempa[100];
        sprintf(tempa,"%i",(*listofdecaymember_it)->z+(*listofdecaymember_it)->n);
        riname[k] = TString(tempa)+(*listofdecaymember_it)->name;
        parms[k]=(*listofdecaymember_it)->decay_lamda;
        parms[pknri+k]=(*listofdecaymember_it)->decay_p1n;
        parms[pknri*2+k]=(*listofdecaymember_it)->decay_p2n;
        parms[pknri*3+k]=(*listofdecaymember_it)->population_ratio;


        parmserr[k]=(*listofdecaymember_it)->decay_lamdaerr;
        parmserr[pknri+k]=(*listofdecaymember_it)->decay_p1nerr;
        parmserr[pknri*2+k]=(*listofdecaymember_it)->decay_p2nerr;
        parmserr[pknri*3+k]=(*listofdecaymember_it)->population_ratioerr;

        parmsmin[k]=(*listofdecaymember_it)->decay_lamdalow;
        parmsmin[pknri+k]=(*listofdecaymember_it)->decay_p1nlow;
        parmsmin[pknri*2+k]=(*listofdecaymember_it)->decay_p2nlow;
        parmsmin[pknri*3+k]=(*listofdecaymember_it)->population_ratiolow;

        parmsmax[k]=(*listofdecaymember_it)->decay_lamdaup;
        parmsmax[pknri+k]=(*listofdecaymember_it)->decay_p1nup;
        parmsmax[pknri*2+k]=(*listofdecaymember_it)->decay_p2nup;
        parmsmax[pknri*3+k]=(*listofdecaymember_it)->population_ratioup;

        isparmsfix[k]=(*listofdecaymember_it)->is_decay_lamda_fix;
        isparmsfix[pknri+k]=(*listofdecaymember_it)->is_decay_p1n_fix;
        isparmsfix[pknri*2+k]=(*listofdecaymember_it)->is_decay_p2n_fix;
        isparmsfix[pknri*3+k]=(*listofdecaymember_it)->is_population_ratio_fix;
        k++;
    }

    k=0;
    for (Int_t i=0;i<pknri*4;i++){
        cout<<"parms "<<i<<" : ";
        cout<<riname[i]<<"\t"<<parms[i]<<"\t"<<parmserr[i]<<"\t"<<parmsmin[i]<<"\t"<<parmsmax[i]<<"\t"<<isparmsfix[i]<<endl;
        if (isparmsfix[i]!=2){
            indexparmsactive[i]=k;
            k++;
        }
    }
    nparmsactive = k;

    //! delete all info
    for (listofdecaymember_it = listofdecaymember.begin(); listofdecaymember_it != listofdecaymember.end(); listofdecaymember_it++){
        delete (*listofdecaymember_it);
    }
    listofdecaymember.clear();
    return 0;

}

//!--------------------------------------------------------------//
//!---------- END MAKE PATH------------------------------------------//


class fitF : public RooAbsPdf {
public:
  fitF() {} ;
  fitF(const char *name, const char *title,
              RooAbsReal& _x,
              RooAbsCategory& _y,
              RooAbsReal& _neueff,
              RooAbsReal& _p0,
              RooAbsReal& _p1,
              RooAbsReal& _p2,
              RooAbsReal& _p3,
              RooAbsReal& _p4,
              RooAbsReal& _p5,
              RooAbsReal& _p6,
              RooAbsReal& _p7,
              RooAbsReal& _p8,
              RooAbsReal& _p9,
              RooAbsReal& _p10,
              RooAbsReal& _p11,
              RooAbsReal& _p12,
              RooAbsReal& _p13,
              RooAbsReal& _p14,
              RooAbsReal& _p15,
              RooAbsReal& _p16,
              RooAbsReal& _p17,
              RooAbsReal& _p18,
              RooAbsReal& _p19,
              RooAbsReal& _p20,
              RooAbsReal& _p21);
  fitF(const fitF& other, const char* name=0) ;
  virtual TObject* clone(const char* newname) const { return new fitF(*this,newname); }
  inline virtual ~fitF() { }

protected:

  RooRealProxy x ;
  RooCategoryProxy y ;
  RooRealProxy neueff ;
  RooRealProxy p0 ;
  RooRealProxy p1 ;
  RooRealProxy p2 ;
  RooRealProxy p3 ;
  RooRealProxy p4 ;
  RooRealProxy p5 ;
  RooRealProxy p6 ;
  RooRealProxy p7 ;
  RooRealProxy p8 ;
  RooRealProxy p9 ;
  RooRealProxy p10 ;
  RooRealProxy p11 ;
  RooRealProxy p12 ;
  RooRealProxy p13 ;
  RooRealProxy p14 ;
  RooRealProxy p15 ;
  RooRealProxy p16 ;
  RooRealProxy p17 ;
  RooRealProxy p18 ;
  RooRealProxy p19 ;
  RooRealProxy p20 ;
  RooRealProxy p21 ;

  Double_t evaluate() const ;

  Double_t corefcn(Int_t ndecay,Int_t* decaymap,Int_t* nneu, Double_t* b1n,Double_t* b2n,Double_t* lamda,Double_t N0,Double_t t) const;
  Double_t fcn_gen(Double_t t, Double_t *par) const;
  Double_t fcn_gen_w1neutron(Double_t t, Double_t *par) const;
  Double_t fcn_gen_w2neutron(Double_t t, Double_t *par) const;


  Double_t pcorefcn(Int_t ndecay,Int_t*  idecaymap,Int_t*  inneu,Double_t* production_yield, Double_t* b1n,Double_t* b2n,Double_t* lamda,Double_t N0,Double_t t) const;
  Double_t pfcn_decay(Double_t *x, Double_t *par) const;
  Double_t pfcn_1ndecay(Double_t *x, Double_t *par) const;
  Double_t pfcn_2ndecay(Double_t *x, Double_t *par) const;

private:

  ClassDef(fitF,1) // Your description goes here...
};

#endif
